Description: pass the right arguments to EFI_PXE_BASE_CODE_TFTP_READ_FILE
 A wrong pointer was being passed to EFI_PXE_BASE_CODE_TFTP_READ_FILE,
 preventing us from getting the file size back from the tftp call, ensuring
 that we don't have enough information to properly secureboot-validate the
 retrieved image.
Author: Steve Langasek <steve.langasek@ubuntu.com>

=== modified file 'netboot.c'
--- a/netboot.c	2013-05-31 19:34:11 +0000
+++ b/netboot.c	2013-09-20 16:07:27 +0000
@@ -326,7 +326,7 @@
 	return rc;
 }
 
-EFI_STATUS FetchNetbootimage(EFI_HANDLE image_handle, VOID **buffer, UINTN *bufsiz)
+EFI_STATUS FetchNetbootimage(EFI_HANDLE image_handle, VOID **buffer, UINT64 *bufsiz)
 {
 	EFI_STATUS rc;
 	EFI_PXE_BASE_CODE_TFTP_OPCODE read = EFI_PXE_BASE_CODE_TFTP_READ_FILE;
@@ -344,7 +344,7 @@
 
 try_again:
 	rc = uefi_call_wrapper(pxe->Mtftp, 10, pxe, read, *buffer, overwrite,
-				&bufsiz, &blksz, &tftp_addr, full_path, NULL, nobuffer);
+				bufsiz, &blksz, &tftp_addr, full_path, NULL, nobuffer);
 
 	if (rc == EFI_BUFFER_TOO_SMALL) {
 		/* try again, doubling buf size */

=== modified file 'shim.c'
--- a/shim.c	2013-08-08 15:12:06 +0000
+++ b/shim.c	2013-09-20 16:12:39 +0000
@@ -1161,7 +1161,7 @@
 	EFI_DEVICE_PATH *path;
 	CHAR16 *PathName = NULL;
 	void *sourcebuffer = NULL;
-	UINTN sourcesize = 0;
+	UINT64 sourcesize = 0;
 	void *data = NULL;
 	int datasize;
 

